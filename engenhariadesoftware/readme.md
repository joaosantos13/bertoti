Atividade 1. Comentário com suas palavras o primeiro trecho do livro Software Engineering at Google, Oreilly.

Em software, o valor relatado está nas linhas de código isoladas, mas nas propriedades não visíveis que emergem do sistema: capacidade de evolução sem fricção, previsibilidade operacional, segurança, legibilidade coletiva e aderência ao domínio. Programar entrega a solução imediata; engenharia de software gerencia esses intangíveis ao transformá-los em arquitetos verificáveis ​​— arquitetura e decisões registradas, automação de construção e implantação, testes de vários níveis, observabilidade, SLOs e governança técnica. Como nas engenharias clássicas, o objetivo é reduzir a incerteza: não para evitar todos os erros, mas para tornar falhas raras, baratas e recuperáveis ​​ao longo do tempo.

Programar e fazer engenharia de software não é a mesma atividade. No uso cotidiano, os termos se confundem, mas na prática apontam para responsabilidades específicas. Programar é o ato de produzir código para resolver um problema específico, geralmente com foco no curto prazo. Engenharia de software, por sua vez, pressupõe aplicar princípios e conhecimento técnico para construir sistemas reais, organizados e confiáveis, em um nível de habilidade ao de engenharia tradicional como a civil ou a mecânica.

A diferença é que essas engenharias clássicas, normas e métodos foram consolidados porque erros podem causar danos físicos. Em software isso nem sempre existe com o mesmo rigor. Só que, como hoje os programas são controlados desde bancos até hospitais, o desenvolvimento precisa ser contínuo com processos mais sólidos, critérios de qualidade e preocupação com segurança e confiabilidade ao longo do tempo.

Atividade 2. Comentário com suas palavras o segundo trecho do livro Software Engineering at Google, Oreilly.

“Engenharia de software” vai muito além de escrever funções. Ela abrange o conjunto de práticas, processos e ferramentas que mantêm um sistema útil e saudável durante todo o seu ciclo de vida. Em outras palavras, é a programação pensada ao longo do tempo: da concepção inicial à manutenção, evolução contínua e, quando necessário, a desativação controlada.

Três fundamentos devem orientar as decisões técnicas:

Tempo e mudança: aceite que o software irá evoluir; projeto para facilitar alteração, correção e adaptação.

Escala e crescimento: considere como equipe, dados e tráfego vão aumentar e o que isso exige de arquitetura e operações.

Trade-offs e custos: toda decisão tem preço; comparar alternativas de interesse presentes e futuros.

Atividade 3. Listar e explicar 3 exemplos de tradeoffs

A) Entrega rápida × Qualidade do código Pressões de prazo podem levar a pular testes, ignorar padrões e “dar um jeitinho” para lançar logo. Funciona no curto prazo, mas costuma gerar dívida técnica, dificultando a manutenção e aumentando o risco de falhas. A pergunta honesta é: o ganho imediato compensa o retrabalho e os bugs futuros?

B) Arquitetura sofisticada × Facilidade de manutenção Soluções mais complexas podem suportar cenários avançados e escalar melhor. Em contrapartida, multiplicam-se camadas e abstrações, elevando a curva de aprendizado e tornando mudanças triviais mais custosas. Vale ponderar se o benefício de longo prazo supera complexidade extra no dia a dia.

C) Desempenho extremo × Legibilidade do código Algumas otimizações rendem milissegundos a menos, mas desative técnicas obscuras ou código menos legível. No futuro, isso pode dificultar correções e evoluções. É preciso decidir quando a clareza e a manutenção pesam mais do que o ganho marginal de desempenho.   

4- UML

![img uml](https://github.com/joaosantos13/bertoti/blob/main/engenhariadesoftware/img/UML.png)

5- Classe Produto 

![img uml](https://github.com/joaosantos13/bertoti/blob/main/engenhariadesoftware/img/img1.png)

Classe Cliente 

![img uml](https://github.com/joaosantos13/bertoti/blob/main/engenhariadesoftware/img/img3.png)

Classe Carrinho

![img uml](https://github.com/joaosantos13/bertoti/blob/main/engenhariadesoftware/img/img2.png)

Classe Main

![img uml](https://github.com/joaosantos13/bertoti/blob/main/engenhariadesoftware/img/image.png)
![img uml](https://github.com/joaosantos13/bertoti/blob/main/engenhariadesoftware/img/img4.png)

6- Testes

![img uml](https://github.com/joaosantos13/bertoti/blob/main/engenhariadesoftware/img/imgTeste.png)

7- Biblioteca
![img uml](https://github.com/joaosantos13/bertoti/blob/main/engenhariadesoftware/img/imgBiblioteca.png)




